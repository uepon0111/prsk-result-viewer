<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>プロセカ リザルト管理マネージャー</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>

    <style>
      :root {
        --bg-color: #121212;
        --card-bg: #1e1e1e;
        --primary: #39c5bb; /* Miku Green */
        --accent: #ff55bb;
        --text-main: #e0e0e0;
        --text-sub: #aaaaaa;
        --danger: #ff4444;
        --good: #ff66cc;
        --bad: #9966ff;
        --miss: #888888;
      }

      body {
        margin: 0;
        font-family: 'Noto Sans JP', sans-serif;
        background-color: var(--bg-color);
        color: var(--text-main);
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }

      /* --- Header --- */
      header {
        background-color: #252525;
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        z-index: 100;
      }
      .logo { font-weight: 700; font-size: 1.2rem; color: var(--primary); display: flex; align-items: center; gap: 8px; }
      .header-controls { display: flex; gap: 10px; align-items: center; }

      /* --- Buttons --- */
      button {
        cursor: pointer;
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-family: inherit;
        font-weight: 600;
        transition: 0.2s;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .btn-primary { background-color: var(--primary); color: #000; }
      .btn-primary:hover { opacity: 0.9; }
      .btn-danger { background-color: var(--danger); color: white; }
      .btn-secondary { background-color: #444; color: white; }
      .btn-secondary:hover { background-color: #555; }
      .btn-icon { padding: 8px; border-radius: 50%; }

      /* --- Filters --- */
      .filter-bar {
        padding: 10px 20px;
        background-color: #1a1a1a;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        border-bottom: 1px solid #333;
      }
      select, input[type="text"], input[type="number"] {
        background-color: #333;
        border: 1px solid #555;
        color: white;
        padding: 6px;
        border-radius: 4px;
      }

      /* --- Main Grid --- */
      .main-content {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        position: relative;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 15px;
      }

      /* --- Card --- */
      .card {
        background-color: var(--card-bg);
        border-radius: 8px;
        overflow: hidden;
        transition: transform 0.2s, box-shadow 0.2s;
        position: relative;
        cursor: pointer;
        border: 2px solid transparent;
      }
      .card:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
      .card.selected { border-color: var(--primary); background-color: #2a3a3a; }
      .card.is-fc .card-img-container { border-bottom: 3px solid #ffd700; }

      .card-img-container {
        width: 100%;
        aspect-ratio: 16/9;
        background-color: #000;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .card-img { width: 100%; height: 100%; object-fit: contain; opacity: 0; transition: opacity 0.3s; }
      
      .fc-badge {
        position: absolute; top: 5px; left: 5px;
        background: linear-gradient(45deg, #ffd700, #ffaa00);
        color: #000; font-weight: bold; font-size: 0.7rem;
        padding: 2px 6px; border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        z-index: 2; display: flex; align-items: center; gap: 2px;
      }

      .card-body { padding: 10px; }
      .song-title { font-size: 0.9rem; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
      .song-meta { display: flex; gap: 5px; font-size: 0.75rem; margin-bottom: 6px; }
      .tag { padding: 2px 5px; border-radius: 3px; color: #fff; font-weight: bold; }
      .tag.lvl { background-color: #444; }
      
      /* Diff Colors */
      .diff-M { background-color: #aa00ff; } /* Master */
      .diff-E { background-color: #ff3366; } /* Expert */
      .diff-H { background-color: #ffaa00; } /* Hard */
      .diff-A { background-color: #ff0066; } /* Append (Example) */

      .score-info { font-size: 0.8rem; color: var(--text-sub); display: flex; justify-content: space-between; }
      .miss-val { color: var(--danger); font-weight: bold; }
      .miss-val.zero { color: #ffd700; }

      /* --- Overlay Actions (Hover) --- */
      .card-overlay-actions {
        position: absolute; top: 0; right: 0; bottom: 0; left: 0;
        background: rgba(0,0,0,0.6);
        display: flex; justify-content: center; align-items: center; gap: 10px;
        opacity: 0; transition: opacity 0.2s;
        z-index: 5;
      }
      .card:hover .card-overlay-actions { opacity: 1; }
      .select-mode-active .card-overlay-actions { display: none !important; }
      
      .btn-overlay {
        background: white; color: black;
        width: 36px; height: 36px; border-radius: 50%;
        display: flex; justify-content: center; align-items: center;
        cursor: pointer;
      }
      .btn-overlay:hover { background: var(--primary); }
      .btn-overlay.del:hover { background: var(--danger); color: white; }

      /* --- Batch Action Bar --- */
      .batch-actions-bar {
        position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
        background-color: #252525; padding: 10px 20px; border-radius: 30px;
        display: none; gap: 15px; align-items: center;
        box-shadow: 0 5px 20px rgba(0,0,0,0.8);
        z-index: 50; border: 1px solid #444;
      }

      /* --- Modals --- */
      .modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 1000;
        display: none; justify-content: center; align-items: center;
      }
      .modal-content {
        background: #1e1e1e; width: 90%; max-width: 1000px; height: 85vh;
        border-radius: 8px; display: flex; flex-direction: column;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      }
      .modal-header {
        padding: 15px 20px; border-bottom: 1px solid #333;
        display: flex; justify-content: space-between; align-items: center;
      }
      .modal-body { flex: 1; display: flex; overflow: hidden; }

      /* Batch Editor Layout */
      .batch-sidebar {
        width: 250px; background: #151515; border-right: 1px solid #333;
        overflow-y: auto; display: flex; flex-direction: column;
      }
      .sidebar-item {
        padding: 10px; border-bottom: 1px solid #2a2a2a; cursor: pointer;
        display: flex; gap: 10px; align-items: center; transition: 0.2s;
      }
      .sidebar-item:hover { background: #222; }
      .sidebar-item.active { background: #2a3a3a; border-left: 3px solid var(--primary); }
      .sidebar-thumb { width: 50px; height: 28px; object-fit: cover; border-radius: 3px; background: #000; }
      .sidebar-info { flex: 1; overflow: hidden; }
      .sidebar-title { font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .sidebar-status { font-size: 0.7rem; display: flex; justify-content: space-between; align-items: center; margin-top: 2px;}

      .batch-main { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; }
      
      /* Upload Zone */
      .upload-initial {
        flex: 1; display: flex; flex-direction: column;
        justify-content: center; align-items: center; gap: 20px;
        border: 2px dashed #444; border-radius: 10px; margin: 20px;
        color: #888;
      }
      .upload-initial.dragover { border-color: var(--primary); background: rgba(57, 197, 187, 0.1); }

      /* Editor Form */
      .editor-container { display: flex; gap: 20px; height: 100%; }
      .editor-preview { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #000; border-radius: 8px; overflow: hidden; }
      .editor-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }
      .editor-form { width: 320px; display: flex; flex-direction: column; gap: 15px; }

      .form-group { display: flex; flex-direction: column; gap: 5px; }
      .form-group label { font-size: 0.8rem; color: #aaa; }
      .form-row { display: flex; gap: 10px; }
      
      .input-group-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px; }
      .stat-box { background: #252525; padding: 10px; border-radius: 5px; text-align: center; }
      
      /* 文字の縁取り用クラス */
      .text-outline {
        text-shadow: 
           -1px -1px 0 #000,  
            1px -1px 0 #000,
           -1px 1px 0 #000,
            1px 1px 0 #000;
        font-weight: 800;
        font-size: 0.9rem;
      }

      .stat-label-good { color: var(--good); }
      .stat-label-bad { color: var(--bad); }
      .stat-label-miss { color: var(--miss); }

      .upload-status { padding: 2px 6px; border-radius: 3px; font-weight: bold; }
      .upload-status.pending { color: #aaa; }
      .upload-status.processing { color: #4fc3f7; }
      .upload-status.done { color: #66bb6a; }
      .upload-status.error { color: #ef5350; }

      .btn-remove-side { background: none; color: #666; padding: 2px; }
      .btn-remove-side:hover { color: #ff4444; background: none; }

      /* Spinner */
      .loader-overlay {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: var(--bg-color); z-index: 50;
        display: flex; flex-direction: column;
        justify-content: center; align-items: center;
      }
      .spinner {
        width: 40px; height: 40px; border: 4px solid #333;
        border-top: 4px solid var(--primary); border-radius: 50%;
        animation: spin 1s linear infinite; margin-bottom: 10px;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

      /* Img Spinner */
      .img-loader-spinner {
        position: absolute; width: 20px; height: 20px;
        border: 2px solid transparent; border-top: 2px solid var(--primary);
        border-radius: 50%; animation: spin 0.8s linear infinite;
      }

    </style>
  </head>
  <body>

    <div id="loader" class="loader-overlay">
      <div class="spinner"></div>
      <div id="loader-text">Loading System...</div>
      <button id="btn-auth" class="btn-primary" style="display:none; margin-top:20px;">Google Drive 連携</button>
    </div>

    <header>
      <div class="logo"><span class="material-symbols-outlined">library_music</span> Proseka Result Manager</div>
      <div class="header-controls">
        <button class="btn-secondary" onclick="openBatchModal('upload')"><span class="material-symbols-outlined">cloud_upload</span> Upload</button>
        <button id="btn-select-mode" class="btn-secondary" onclick="toggleSelectMode()"><span class="material-symbols-outlined">checklist</span> 選択</button>
        <button class="btn-secondary" onclick="fetchDataFromDrive()" title="更新"><span class="material-symbols-outlined">refresh</span></button>
      </div>
    </header>

    <div class="filter-bar">
      <input type="text" id="filter-title" placeholder="曲名検索..." oninput="updateView()">
      <select id="filter-level" onchange="updateView()">
        <option value="">Lv. 全て</option>
        </select>
      <select id="filter-diff" onchange="updateView()">
        <option value="all">難易度: 全て</option>
        <option value="M">MASTER</option>
        <option value="E">EXPERT</option>
        <option value="H">HARD</option>
        <option value="A">APPEND</option>
      </select>
      <select id="filter-fc" onchange="updateView()">
        <option value="all">状態: 全て</option>
        <option value="fc">FULL COMBO</option>
        <option value="unfc">未フルコン</option>
      </select>
      <div style="display:flex; align-items:center; gap:5px; font-size:0.8rem;">
        Miss: <input type="number" id="filter-miss-min" style="width:50px;" placeholder="Min" oninput="updateView()">
        ~ <input type="number" id="filter-miss-max" style="width:50px;" placeholder="Max" oninput="updateView()">
      </div>
      <select id="sort-order" onchange="updateView()" style="margin-left:auto;">
        <option value="level_desc">Lv 降順</option>
        <option value="level_asc">Lv 昇順</option>
        <option value="miss_asc">Miss 少ない順</option>
        <option value="miss_desc">Miss 多い順</option>
        <option value="title_asc">曲名 あ-ん</option>
      </select>
      <div id="result-count" style="font-size:0.8rem; color:#888;"></div>
    </div>

    <div class="main-content">
      <div id="grid" class="grid">
        </div>
    </div>

    <div id="batch-actions" class="batch-actions-bar">
      <span style="font-weight:bold;"><span id="selected-count">0</span> 件選択中</span>
      <button class="btn-primary" onclick="batchEdit()"><span class="material-symbols-outlined">edit</span> 編集</button>
      <button class="btn-danger" onclick="batchDelete()"><span class="material-symbols-outlined">delete</span> 削除</button>
      <button class="btn-secondary" onclick="clearSelection()">キャンセル</button>
    </div>

    <div id="imageModal" class="modal-overlay" onclick="closeImageModal()">
      <div style="position:relative; max-width:90%; max-height:90%;">
        <img id="modalImg" src="" style="max-width:100%; max-height:90vh; border-radius:4px; box-shadow:0 0 20px black;">
      </div>
    </div>

    <div id="batchModal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <div id="batch-modal-title" style="font-size:1.1rem; font-weight:bold; display:flex; gap:10px;"></div>
          <button class="btn-secondary" onclick="closeBatchModal()"><span class="material-symbols-outlined">close</span></button>
        </div>
        <div class="modal-body">
          <div class="batch-sidebar" id="batch-sidebar-list">
            </div>

          <div class="batch-main">
            
            <div id="upload-initial" class="upload-initial">
              <span class="material-symbols-outlined" style="font-size:4rem; color:#444;">cloud_upload</span>
              <div>ここに画像をドラッグ＆ドロップ</div>
              <div style="font-size:0.9rem;">または</div>
              <input type="file" id="up-file" multiple accept="image/*" style="display:none;">
              <button class="btn-primary" onclick="document.getElementById('up-file').click()">ファイルを選択</button>
            </div>

            <div id="batch-workspace" style="display:none; flex-direction:column; height:100%;">
              <div id="batch-editor-container" class="editor-container">
                <div class="editor-preview">
                  <img id="batch-preview-img" src="">
                </div>
                <div class="editor-form">
                  <div class="form-group">
                    <label>曲名 (Title)</label>
                    <div style="display:flex; gap:5px;">
                        <input type="text" id="up-title" style="flex:1;" oninput="updateCurrentItem('title', this.value)">
                        <button class="btn-secondary" onclick="reanalyzeCurrentItem()" title="再解析"><span class="material-symbols-outlined">cached</span></button>
                    </div>
                  </div>
                  <div class="form-row">
                    <div class="form-group" style="flex:1;">
                      <label>Level</label>
                      <input type="number" id="up-level" oninput="updateCurrentItem('level', this.value)">
                    </div>
                    <div class="form-group" style="flex:1;">
                      <label>Diff</label>
                      <select id="up-diff" onchange="updateCurrentItem('diff', this.value)">
                        <option value="M">MASTER</option>
                        <option value="E">EXPERT</option>
                        <option value="H">HARD</option>
                        <option value="A">APPEND</option>
                      </select>
                    </div>
                  </div>
                  
                  <div class="input-group-grid">
                    <div class="stat-box">
                      <label class="text-outline stat-label-good">GOOD</label>
                      <input type="number" id="up-good" style="width:100%; text-align:center;" oninput="updateCurrentItem('good', this.value)">
                    </div>
                    <div class="stat-box">
                      <label class="text-outline stat-label-bad">BAD</label>
                      <input type="number" id="up-bad" style="width:100%; text-align:center;" oninput="updateCurrentItem('bad', this.value)">
                    </div>
                    <div class="stat-box">
                      <label class="text-outline stat-label-miss">MISS</label>
                      <input type="number" id="up-miss-detail" style="width:100%; text-align:center;" oninput="updateCurrentItem('missDetail', this.value)">
                    </div>
                  </div>
                  
                  <div style="text-align:right; font-size:0.9rem; color:#aaa; margin-top:5px;">
                    Total Miss: <span id="up-total-miss" style="color:#fff; font-weight:bold;">0</span>
                  </div>

                </div>
              </div>
              
              <div id="batch-empty-msg" style="display:none; text-align:center; padding:50px; color:#666;">
                項目を選択してください
              </div>

              <div style="margin-top:auto; padding-top:20px; border-top:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
                <span id="batch-status-msg" style="color:#aaa; font-size:0.9rem;"></span>
                <button id="btn-exec-batch" class="btn-primary" onclick="handleBatchExecution()">保存して反映</button>
              </div>
            </div>

          </div>
        </div>
      </div>
    </div>

    <script>
      /* --- Config & DB --- */
      // CLIENT_ID / API_KEY はご自身のものに置き換えてください
      const CLIENT_ID = 'YOUR_GOOGLE_CLIENT_ID';
      const API_KEY = 'YOUR_GOOGLE_API_KEY';
      const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
      const SCOPES = "https://www.googleapis.com/auth/drive.file";

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;
      
      let allRecords = [];
      let filteredRecords = [];
      let dbMusics = []; // Simplified music DB for matching
      let dbDiffs = [];  // Simplified diff DB
      // Note: In a real app, you would fetch a JSON of Musics/Diffs here.
      // For demo, I'll mock a simple matching logic or empty.

      let isSelectMode = false;
      let selectedIds = new Set();
      
      // Batch State
      let editorQueue = []; // { id, file, imgUrl, data: {title, level, diff, good, bad, missDetail, totalMiss, musicId}, status }
      let activeItemId = null;
      let currentMode = 'upload'; // 'upload' | 'edit'

      const diffRank = { 'A':4, 'M':3, 'E':2, 'H':1 };

      /* --- Auth --- */
      function gapiLoaded() {
        gapi.load('client', initializeGapiClient);
      }
      async function initializeGapiClient() {
        await gapi.client.init({ apiKey: API_KEY, discoveryDocs: DISCOVERY_DOCS });
        gapiInited = true;
        maybeEnableAuth();
      }
      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID, scope: SCOPES,
          callback: async (resp) => {
            if (resp.error !== undefined) throw (resp);
            document.getElementById('btn-auth').style.display = 'none';
            document.getElementById('loader-text').innerText = "データを取得中...";
            await fetchDataFromDrive();
          },
        });
        gisInited = true;
        maybeEnableAuth();
      }
      function maybeEnableAuth() {
        if (gapiInited && gisInited) {
          document.getElementById('loader-text').innerText = "認証が必要です";
          document.getElementById('btn-auth').style.display = 'block';
          document.getElementById('btn-auth').onclick = handleAuthClick;
          
          // Populate Level Filter
          const sel = document.getElementById('filter-level');
          for(let i=37; i>=20; i--) { const op = document.createElement('option'); op.value=i; op.innerText="Lv."+i; sel.appendChild(op); }
        }
      }
      function handleAuthClick() {
        tokenClient.requestAccessToken({ prompt: 'consent' });
      }

      /* --- Drive Data Logic --- */
      async function fetchDataFromDrive() {
        try {
          // 1. Find Root Folder "プロセカリザルト"
          const qRoot = "mimeType = 'application/vnd.google-apps.folder' and name = 'プロセカリザルト' and trashed = false";
          const resRoot = await gapi.client.drive.files.list({ q: qRoot, fields: 'files(id, name)' });
          
          if (resRoot.result.files.length === 0) {
             onDataLoaded(); // Empty
             return;
          }
          const rootId = resRoot.result.files[0].id;

          // 2. Find "FC" folder inside
          const qFC = `'${rootId}' in parents and mimeType = 'application/vnd.google-apps.folder' and name = 'FC' and trashed = false`;
          const resFC = await gapi.client.drive.files.list({ q: qFC, fields: 'files(id, name)' });
          
          if (resFC.result.files.length === 0) { onDataLoaded(); return; }
          const fcFolderId = resFC.result.files[0].id;

          // 3. List all Song Folders inside FC
          // Expecting folder name like "33M Disappearance"
          let songFolders = [];
          let pageToken = null;
          do {
            const resSongs = await gapi.client.drive.files.list({
              q: `'${fcFolderId}' in parents and mimeType = 'application/vnd.google-apps.folder' and trashed = false`,
              fields: 'nextPageToken, files(id, name)',
              pageSize: 1000,
              pageToken: pageToken
            });
            songFolders = songFolders.concat(resSongs.result.files);
            pageToken = resSongs.result.nextPageToken;
          } while (pageToken);

          // 4. For each song folder, look for result image
          // Optimization: We could batch requests, but for simplicity loop linearly or Parallel.all
          // To make it faster, we won't deep scan files unless needed. 
          // We will assume 1 file per folder for now or take the first image.
          
          const records = [];
          
          // Chunking requests to avoid rate limit slightly
          const chunks = [];
          const chunkSize = 10;
          for (let i = 0; i < songFolders.length; i += chunkSize) chunks.push(songFolders.slice(i, i + chunkSize));

          document.getElementById('loader-text').innerText = `リザルト収集中... (0/${songFolders.length})`;
          let processed = 0;

          for (const chunk of chunks) {
            await Promise.all(chunk.map(async (folder) => {
              const parsed = parseFolderTitle(folder.name);
              if (!parsed) return;

              // Find image inside
              const qImg = `'${folder.id}' in parents and mimeType contains 'image/' and trashed = false`;
              const resImg = await gapi.client.drive.files.list({ q: qImg, fields: 'files(id, name, thumbnailLink)', pageSize: 1 });
              
              if (resImg.result.files.length > 0) {
                const file = resImg.result.files[0];
                const missCount = parseScore(file.name);
                records.push({
                  id: file.id,
                  parentId: folder.id, // For moving/renaming
                  title: parsed.title,
                  level: parsed.level,
                  difficultyRaw: parsed.rawDiff,
                  difficulty: parsed.difficulty,
                  isFC: (missCount === 0),
                  missCount: missCount || 0,
                  thumbnail: file.thumbnailLink
                });
              }
            }));
            processed += chunk.length;
            document.getElementById('loader-text').innerText = `リザルト収集中... (${Math.min(processed, songFolders.length)}/${songFolders.length})`;
          }

          allRecords = records;
          updateView();
          onDataLoaded();

        } catch (e) {
          console.error(e);
          alert("データ取得エラー: " + e.message);
          document.getElementById('loader').style.display = 'none';
        }
      }

      /* --- Batch UI & Logic --- */
      
      function openBatchModal(mode) {
        currentMode = mode;
        document.getElementById('batchModal').style.display = 'flex';
        editorQueue = [];
        document.getElementById('batch-sidebar-list').innerHTML = '';
        document.getElementById('batch-editor-container').style.display = 'none';
        document.getElementById('batch-empty-msg').style.display = 'block';
        document.getElementById('batch-status-msg').innerText = "";
        activeItemId = null;
        
        if (mode === 'upload') {
            document.getElementById('batch-modal-title').innerHTML = '<span class="material-symbols-outlined">cloud_upload</span> 画像アップロード';
            document.getElementById('upload-initial').style.display = 'flex';
            document.getElementById('batch-workspace').style.display = 'none';
            document.getElementById('up-file').value = "";
            document.getElementById('btn-exec-batch').innerText = "全てアップロード";
        } else {
            document.getElementById('batch-modal-title').innerHTML = '<span class="material-symbols-outlined">edit_square</span> 編集・解析モード';
            document.getElementById('upload-initial').style.display = 'none';
            document.getElementById('batch-workspace').style.display = 'flex';
            document.getElementById('btn-exec-batch').innerText = "保存して反映";
            // Edit mode specific init is handled by caller (batchEdit)
        }
      }

      function closeBatchModal() {
        document.getElementById('batchModal').style.display = 'none';
      }

      // Drop Zone & File Handling (Upload Mode)
      const dropZone = document.getElementById('drop-zone') || document.getElementById('upload-initial'); // Fix ID ref
      dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
      dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); });
      dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); if (e.dataTransfer.files.length > 0) handleFiles(e.dataTransfer.files); });
      document.getElementById('up-file').addEventListener('change', (e) => handleFiles(e.target.files));

      async function handleFiles(files) {
        if (files.length === 0) return;
        document.getElementById('upload-initial').style.display = 'none';
        document.getElementById('batch-workspace').style.display = 'flex';
        document.getElementById('batch-status-msg').innerText = "画像を処理中...";
        
        // Add to queue
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const qId = "new_" + Date.now() + "_" + i;
            editorQueue.push({
                id: qId,
                file: file, // File Object
                imgUrl: URL.createObjectURL(file),
                status: 'pending',
                data: { title:'', level:'', diff:'M', good:0, bad:0, missDetail:0, totalMiss:0, musicId:null },
                originalId: null
            });
            renderSidebarItem(qId);
        }
        
        // Auto Analyze new items
        await runBatchAnalysis(editorQueue.filter(i => i.status === 'pending'));
        
        if (!activeItemId && editorQueue.length > 0) selectItem(editorQueue[0].id);
        checkBatchButton();
      }

      // Initialize Batch Edit from Selection
      async function batchEdit() {
          if (selectedIds.size === 0) return;
          openBatchModal('edit');
          
          const targets = allRecords.filter(r => selectedIds.has(r.id));
          document.getElementById('batch-status-msg').innerText = "編集データを準備中...";

          for (const rec of targets) {
              const qId = "edit_" + rec.id;
              // Use high-res thumbnail for preview/ocr
              const highResUrl = rec.thumbnail ? rec.thumbnail.replace('=s220', '=w1600') : '';
              
              editorQueue.push({
                  id: qId,
                  file: null, // No file object for existing items
                  imgUrl: highResUrl,
                  status: 'existing', // Mark as already existing
                  data: { 
                      title: rec.title, 
                      level: rec.level, 
                      diff: rec.difficultyRaw, 
                      good: 0, bad: 0, missDetail: 0, // Breakdown unknown for existing
                      totalMiss: rec.missCount,
                      musicId: null 
                  },
                  originalId: rec.id,
                  originalParent: rec.parentId
              });
              renderSidebarItem(qId);
              updateSidebarStatus(qId); // Initial validation check
          }
          if (editorQueue.length > 0) selectItem(editorQueue[0].id);
          checkBatchButton();
          document.getElementById('batch-status-msg').innerText = "編集準備完了";
      }

      function renderSidebarItem(id) {
        const item = editorQueue.find(q => q.id === id);
        const div = document.createElement('div');
        div.className = 'sidebar-item';
        div.id = `sb-${id}`;
        div.onclick = () => selectItem(id);
        
        let thumbUrl = item.imgUrl;

        div.innerHTML = `
            <img src="${thumbUrl}" class="sidebar-thumb" crossorigin="anonymous">
            <div class="sidebar-info">
                <div class="sidebar-title" id="sb-title-${id}">${item.data.title || "名称未設定"}</div>
                <div class="sidebar-status">
                    <span id="sb-status-${id}" class="upload-status pending">待機中</span>
                    <button class="btn-remove-side" onclick="removeBatchItem(event, '${id}')">
                        <span class="material-symbols-outlined" style="font-size:1rem;">delete</span>
                    </button>
                </div>
            </div>
        `;
        document.getElementById('batch-sidebar-list').appendChild(div);
      }

      function selectItem(id) {
        activeItemId = id;
        const item = editorQueue.find(q => q.id === id);
        if(!item) return;

        document.querySelectorAll('.sidebar-item').forEach(el => el.classList.remove('active'));
        const sbEl = document.getElementById(`sb-${id}`);
        if(sbEl) sbEl.classList.add('active');

        document.getElementById('batch-editor-container').style.display = 'flex';
        document.getElementById('batch-empty-msg').style.display = 'none';

        const imgEl = document.getElementById('batch-preview-img');
        imgEl.src = item.imgUrl;
        
        document.getElementById('up-title').value = item.data.title;
        document.getElementById('up-level').value = item.data.level;
        document.getElementById('up-diff').value = item.data.diff;
        
        document.getElementById('up-good').value = item.data.good;
        document.getElementById('up-bad').value = item.data.bad;
        document.getElementById('up-miss-detail').value = item.data.missDetail;
        document.getElementById('up-total-miss').innerText = item.data.totalMiss;
      }

      function updateCurrentItem(field, value) {
        if(!activeItemId) return;
        const item = editorQueue.find(q => q.id === activeItemId);
        if(!item) return;

        if(['good', 'bad', 'missDetail', 'level'].includes(field)) {
             item.data[field] = parseInt(value) || 0;
             if (field === 'level' && value === "") item.data[field] = ""; // Allow empty
        } else {
             item.data[field] = value;
        }

        if(field === 'diff' && item.data.musicId) {
             const map = {'A':'append', 'M':'master', 'E':'expert', 'H':'hard'};
             const newLvl = getLevelFromDb(item.data.musicId, map[value]);
             if(newLvl) { item.data.level = newLvl; document.getElementById('up-level').value = newLvl; }
        }

        if(['good', 'bad', 'missDetail'].includes(field)) {
            item.data.totalMiss = item.data.good + item.data.bad + item.data.missDetail;
            document.getElementById('up-total-miss').innerText = item.data.totalMiss;
        }

        if(field === 'title') {
            document.getElementById(`sb-title-${activeItemId}`).innerText = value || "名称未設定";
        }
        
        updateSidebarStatus(activeItemId);
      }

      function updateSidebarStatus(id) {
          const item = editorQueue.find(q => q.id === id);
          if(!item) return;
          const statusEl = document.getElementById(`sb-status-${id}`);
          
          // Validation Logic: Title and Level are required
          const isValid = item.data.title && String(item.data.title).trim() !== "" && item.data.level;

          if (isValid) {
            statusEl.innerText = "OK"; 
            statusEl.className = "upload-status done";
            item.status = 'done';
          } else {
            statusEl.innerText = "必須不足"; // Error indication
            statusEl.className = "upload-status error";
            item.status = 'error'; // Logically incomplete
          }
          checkBatchButton();
      }

      function removeBatchItem(e, id) {
        e.stopPropagation();
        editorQueue = editorQueue.filter(q => q.id !== id);
        document.getElementById(`sb-${id}`).remove();
        if (activeItemId === id) {
            document.getElementById('batch-editor-container').style.display = 'none';
            document.getElementById('batch-empty-msg').style.display = 'block';
            activeItemId = null;
        }
        checkBatchButton();
      }

      function checkBatchButton() {
        const btn = document.getElementById('btn-exec-batch');
        // Optional: Disable if there are errors? 
        // For now, just enable if there are items, but let execute handle/skip errors
        btn.disabled = editorQueue.length === 0;
        
        const label = currentMode === 'upload' ? '全てアップロード' : '保存して反映';
        btn.innerText = editorQueue.length > 0 ? `${label} (${editorQueue.length}件)` : label;
      }

      // --- Analysis Logic ---
      
      async function runBatchAnalysis(itemsToAnalyze) {
          if(itemsToAnalyze.length === 0) return;
          const statusMsg = document.getElementById('batch-status-msg');
          statusMsg.innerText = "解析中... (しばらくお待ちください)";
          
          const worker = await Tesseract.createWorker(['jpn', 'eng']);
          
          for (const item of itemsToAnalyze) {
              const el = document.getElementById(`sb-status-${item.id}`);
              if(el) { el.innerText = "解析中"; el.className = "upload-status processing"; }
              
              const img = new Image();
              img.crossOrigin = "anonymous";
              img.src = item.imgUrl;
              try {
                  await new Promise((resolve, reject) => {
                      img.onload = resolve;
                      img.onerror = reject;
                  });
                  
                  const res = await analyzeLoadedImage(img, worker);
                  if (res) {
                    item.data = {
                        title: res.title, level: res.level, diff: res.diff,
                        good: res.missDetail.good, bad: res.missDetail.bad, missDetail: res.missDetail.miss,
                        totalMiss: res.miss, musicId: res.musicId
                    };
                    // Validation runs in updateSidebarStatus
                  } else {
                    item.status = 'error';
                  }
              } catch (e) {
                  console.error("Analysis Failed for " + item.id, e);
                  item.status = 'error';
              }
              
              if (item.status !== 'error') {
                 document.getElementById(`sb-title-${item.id}`).innerText = item.data.title;
                 if (activeItemId === item.id) selectItem(item.id);
              }
              updateSidebarStatus(item.id);
          }
          await worker.terminate();
          statusMsg.innerText = "処理完了";
      }

      async function reanalyzeCurrentItem() {
          if (!activeItemId) return;
          const item = editorQueue.find(q => q.id === activeItemId);
          if (item) await runBatchAnalysis([item]);
      }

      async function analyzeAllInBatch() {
          if (editorQueue.length === 0) return;
          await runBatchAnalysis(editorQueue);
      }

      async function cropImage(imageElement, xRatio, yRatio, wRatio, hRatio, type = 'filter-standard') {
        const canvas = document.createElement('canvas');
        const w = imageElement.naturalWidth;
        const h = imageElement.naturalHeight;
        const ctx = canvas.getContext('2d');
        
        if (type === 'threshold-diff') {
            const scale = 1.5;
            canvas.width = w * wRatio * scale;
            canvas.height = h * hRatio * scale;
            ctx.drawImage(imageElement, w * xRatio, h * yRatio, w * wRatio, h * hRatio, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                data[i] = data[i+1] = data[i+2] = (gray > 180) ? 0 : 255;
            }
            ctx.putImageData(imageData, 0, 0);
        } else {
            canvas.width = w * wRatio;
            canvas.height = h * hRatio;
            ctx.filter = 'grayscale(100%) contrast(150%)';
            ctx.drawImage(imageElement, w * xRatio, h * yRatio, w * wRatio, h * hRatio, 0, 0, canvas.width, canvas.height);
        }
        return new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
      }

      async function analyzeLoadedImage(imgElement, worker) {
         try {
            // Diff
            const diffBlob = await cropImage(imgElement, 0.20, 0.07, 0.10, 0.04, 'threshold-diff');
            const diffRet = await worker.recognize(diffBlob, { lang: 'eng' }); 
            const diffText = diffRet.data.text.toUpperCase();
            let dCode = "E", dKey = "expert";
            if (diffText.match(/A?P{2}E?N?D?/)) { dCode = "A"; dKey = "append"; }
            else if (diffText.includes("MASTER")) { dCode = "M"; dKey = "master"; }
            else if (diffText.includes("EXPERT")) { dCode = "E"; dKey = "expert"; }
            else if (diffText.includes("HARD")) { dCode = "H"; dKey = "hard"; }

            // Title
            const titleBlob = await cropImage(imgElement, 0.19, 0.01, 0.32, 0.05, 'filter-standard');
            const titleRet = await worker.recognize(titleBlob, { lang: 'jpn' });
            const matchedMusic = findBestMatchMusic(titleRet.data.text);
            const finalTitle = matchedMusic ? matchedMusic.title : titleRet.data.text.replace(/\r?\n/g, '').trim();
            const musicId = matchedMusic ? matchedMusic.id : null;

            // Level
            let level = "";
            if (musicId) level = getLevelFromDb(musicId, dKey) || "";

            // Miss
            const missBlob = await cropImage(imgElement, 0.10, 0.55, 0.20, 0.28, 'filter-standard');
            const missRet = await worker.recognize(missBlob, { lang: 'jpn' });
            const lines = missRet.data.text.split('\n');
            let cGood = 0, cBad = 0, cMiss = 0;
            const parseLine = (line, regex) => { if (regex.test(line)) { const nums = line.match(/\d+/g); if (nums) return parseInt(nums[nums.length - 1], 10); } return 0; };
            lines.forEach(line => {
              if (/G[O0QD]{2}D/i.test(line)) cGood = parseLine(line, /G[O0QD]{2}D/i);
              if (/BAD/i.test(line))  cBad  = parseLine(line, /BAD/i);
              if (/MISS/i.test(line)) cMiss = parseLine(line, /MISS/i);
            });

            return {
                title: finalTitle, level: level, diff: dCode,
                miss: cGood + cBad + cMiss,
                missDetail: { good: cGood, bad: cBad, miss: cMiss },
                musicId: musicId
            };
        } catch (e) { console.error(e); return null; }
      }

      function normalizeString(str) { if (!str) return ""; return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).toLowerCase().replace(/[\s\-_]/g, ''); }
      function findBestMatchMusic(ocrText) {
        if (!dbMusics || dbMusics.length === 0) return null;
        const target = normalizeString(ocrText);
        if (target.length === 0) return null;
        let bestMatch = null, minScore = Infinity;
        const levenshtein = (s1, s2) => {
            if(s1.length > s2.length) [s1,s2] = [s2,s1];
            let dist = Array.from({length: s1.length+1},(_,i)=>i);
            for(let i2=0;i2<s2.length;i2++){
                let newDist = [i2+1];
                for(let i1=0;i1<s1.length;i1++){
                    if(s1[i1]===s2[i2]) newDist.push(dist[i1]);
                    else newDist.push(1+Math.min(dist[i1], dist[i1+1], newDist[newDist.length-1]));
                }
                dist = newDist;
            }
            return dist[dist.length-1];
        };
        for (const music of dbMusics) {
            const dbTitleNorm = normalizeString(music.title);
            const dist = levenshtein(target, dbTitleNorm);
            const score = dist / Math.max(target.length, dbTitleNorm.length);
            if (score < minScore) { minScore = score; bestMatch = music; }
        }
        return bestMatch; 
      }
      function getLevelFromDb(musicId, diffKey) { if (!musicId || !diffKey || !dbDiffs) return null; const entry = dbDiffs.find(d => d.musicId === musicId && d.musicDifficulty === diffKey); return entry ? entry.playLevel : null; }

      // --- Execution Logic (Save/Upload) ---

      async function handleBatchExecution() {
          const btn = document.getElementById('btn-exec-batch');
          
          // Safety check for incompletes
          const hasError = editorQueue.some(q => q.status === 'error' || !q.data.title || !q.data.level);
          if (hasError) {
              if(!confirm("不備(必須不足)のある項目が含まれています。それらはスキップされますがよろしいですか？")) return;
          }

          btn.disabled = true;
          btn.innerText = "処理中...";
          
          if (currentMode === 'upload') {
              await executeUploads();
          } else {
              await executeEdits();
          }
      }

      async function findOrCreateFolder(name, parentId = null) {
        const existing = await getFolderByName(name, parentId);
        if (existing) return existing;
        const metadata = { 'name': name, 'mimeType': 'application/vnd.google-apps.folder' };
        if (parentId) metadata.parents = [parentId];
        const response = await gapi.client.drive.files.create({ resource: metadata, fields: 'id, name' });
        return response.result;
      }
      
      async function getFolderByName(name, parentId) {
          let q = `mimeType = 'application/vnd.google-apps.folder' and name = '${name.replace(/'/g, "\\'")}' and trashed = false`;
          if (parentId) q += ` and '${parentId}' in parents`;
          const res = await gapi.client.drive.files.list({ q: q, fields: 'files(id, name)' });
          return res.result.files.length > 0 ? res.result.files[0] : null;
      }

      async function executeUploads() {
        let successCount = 0;
        const accessToken = gapi.client.getToken().access_token;
        const rootFolder = await findOrCreateFolder("プロセカリザルト");
        const fcFolder = await findOrCreateFolder("FC", rootFolder.id);

        for (const item of [...editorQueue]) {
            // Skip invalid
            if (item.status === 'error' || !item.data.title || !item.data.level) continue;

            const sbStatus = document.getElementById(`sb-status-${item.id}`);
            if(sbStatus) { sbStatus.innerText = "送信中"; sbStatus.className = "upload-status processing"; }
            
            try {
                const folderName = `${item.data.level}${item.data.diff} ${item.data.title}`;
                const songFolder = await findOrCreateFolder(folderName, fcFolder.id);
                const fileName = (item.data.totalMiss === 0) ? "FC" : `FC-${item.data.totalMiss}`;

                const meta = { 'name': fileName, 'parents': [songFolder.id] };
                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(meta)], { type: 'application/json' }));
                form.append('file', item.file);

                const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                    method: 'POST', headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }), body: form
                });
                if (!res.ok) throw new Error(res.statusText);
                
                editorQueue = editorQueue.filter(q => q.id !== item.id);
                document.getElementById(`sb-${item.id}`).remove();
                successCount++;

            } catch (e) {
                console.error(e);
                if(sbStatus) { sbStatus.innerText = "失敗"; sbStatus.className = "upload-status error"; }
            }
        }
        finishExecution(successCount, "アップロード");
      }

      async function executeEdits() {
          let successCount = 0;
          const rootFolder = await findOrCreateFolder("プロセカリザルト");
          const fcFolder = await findOrCreateFolder("FC", rootFolder.id);

          for (const item of [...editorQueue]) {
             if (item.status === 'error' || !item.data.title || !item.data.level) continue;

             const sbStatus = document.getElementById(`sb-status-${item.id}`);
             if(sbStatus) { sbStatus.innerText = "保存中"; sbStatus.className = "upload-status processing"; }

             try {
                const newFolderName = `${item.data.level}${item.data.diff} ${item.data.title}`;
                const newFileName = (item.data.totalMiss === 0) ? "FC" : `FC-${item.data.totalMiss}`;
                
                const targetFolder = await findOrCreateFolder(newFolderName, fcFolder.id);

                const params = { fileId: item.originalId, resource: { name: newFileName } };
                if (targetFolder.id !== item.originalParent) {
                    params.addParents = targetFolder.id;
                    params.removeParents = item.originalParent;
                }
                await gapi.client.drive.files.update(params);

                editorQueue = editorQueue.filter(q => q.id !== item.id);
                document.getElementById(`sb-${item.id}`).remove();
                successCount++;
             } catch (e) {
                 console.error(e);
                 if(sbStatus) { sbStatus.innerText = "失敗"; sbStatus.className = "upload-status error"; }
             }
          }
          finishExecution(successCount, "更新");
      }

      function finishExecution(count, actionName) {
         if (editorQueue.length === 0) {
            alert(`${actionName}完了 (${count}件)`);
            closeBatchModal();
            selectedIds.clear(); 
            updateSelectionUI();
            fetchDataFromDrive();
        } else {
            alert(`${count}件 ${actionName}成功。不備またはエラー分を確認してください。`);
            checkBatchButton();
        }
      }

      // --- Selection Mode Logic ---
      
      function toggleSelectMode() {
          isSelectMode = !isSelectMode;
          const btn = document.getElementById('btn-select-mode');
          if (isSelectMode) {
              btn.classList.add('active');
          } else {
              btn.classList.remove('active');
              selectedIds.clear();
              updateSelectionUI();
          }
          renderGrid(filteredRecords);
      }

      function toggleSelection(id) {
          if (selectedIds.has(id)) selectedIds.delete(id);
          else selectedIds.add(id);
          
          const card = document.getElementById(`card-${id}`);
          if (card) {
              if (selectedIds.has(id)) card.classList.add('selected');
              else card.classList.remove('selected');
          }
          updateSelectionUI();
      }

      function updateSelectionUI() {
          const bar = document.getElementById('batch-actions');
          const countSpan = document.getElementById('selected-count');
          countSpan.innerText = selectedIds.size;
          if (selectedIds.size > 0) {
              bar.style.display = 'flex';
          } else {
              bar.style.display = 'none';
          }
      }
      
      function clearSelection() {
          selectedIds.clear();
          updateSelectionUI();
          renderGrid(filteredRecords);
      }

      // Individual Actions (Non-Select Mode)
      function individualEdit(id) {
          selectedIds.clear();
          selectedIds.add(id);
          batchEdit();
      }

      async function individualDelete(id) {
          if(!confirm("このリザルトを削除しますか？")) return;
          const loader = document.getElementById('loader');
          loader.style.display = 'flex';
          document.getElementById('grid').innerHTML = '';
          try {
              await gapi.client.drive.files.delete({ fileId: id });
              alert("削除しました");
              await fetchDataFromDrive();
          } catch(e) {
              alert("エラー: " + e.message);
              fetchDataFromDrive();
          }
      }

      async function batchDelete() {
          if (!confirm(`選択した ${selectedIds.size} 件を削除しますか？`)) return;
          const loader = document.getElementById('loader');
          loader.style.display = 'flex';
          document.getElementById('grid').innerHTML = '';
          
          try {
              for (const id of selectedIds) {
                  await gapi.client.drive.files.delete({ fileId: id });
              }
              alert("削除しました");
              selectedIds.clear();
              updateSelectionUI();
              await fetchDataFromDrive();
          } catch (e) {
              alert("削除エラー: " + e.message);
              fetchDataFromDrive(); 
          }
      }

      // --- Standard UI Helper ---
      
      function updateView() {
        if (!allRecords) return;
        const fcF = document.getElementById('filter-fc').value;
        const msMin = document.getElementById('filter-miss-min').value;
        const msMax = document.getElementById('filter-miss-max').value;
        const dfF = document.getElementById('filter-diff').value;
        const lvF = document.getElementById('filter-level').value;
        const tiF = document.getElementById('filter-title').value.trim().toLowerCase();

        let list = allRecords;

        list = list.filter(r => {
          if (fcF === 'fc' && !r.isFC) return false;
          if (fcF === 'unfc' && r.isFC) return false;
          if (!r.isFC) {
              const mVal = r.missCount;
              if (msMin !== "" && mVal < parseInt(msMin)) return false;
              if (msMax !== "" && mVal > parseInt(msMax)) return false;
          } else {
              if (msMin !== "" && 0 < parseInt(msMin)) return false;
          }
          if (dfF !== 'all' && r.difficultyRaw !== dfF) return false;
          if (lvF && r.level != lvF) return false;
          if (tiF && !r.title.toLowerCase().includes(tiF)) return false;
          return true;
        });

        const sOrder = document.getElementById('sort-order').value;
        list.sort((a, b) => {
          const tAsc = a.title.localeCompare(b.title, 'ja'), tDesc = b.title.localeCompare(a.title, 'ja');
          const lDiff = b.level - a.level, lAsc = a.level - b.level;
          const dDiff = diffRank[b.difficultyRaw] - diffRank[a.difficultyRaw]; 
          const mAsc = a.missCount - b.missCount, mDesc = b.missCount - a.missCount;

          if(sOrder === 'title_asc') return tAsc || dDiff || mAsc;
          if(sOrder === 'title_desc') return tDesc || dDiff || mAsc;
          if(sOrder === 'level_desc') return lDiff || tAsc || dDiff || mAsc;
          if(sOrder === 'level_asc') return lAsc || tAsc || dDiff || mAsc;
          if(sOrder === 'miss_asc') return mAsc || lDiff || dDiff;
          return mDesc || lDiff || dDiff;
        });
        
        filteredRecords = list;
        renderGrid(list);
      }

      function renderGrid(records) {
        const grid = document.getElementById('grid');
        document.getElementById('result-count').innerText = `表示: ${records.length} 件`;
        grid.innerHTML = '';
        if (records.length === 0) { grid.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:20px; color:#666;">データなし</div>'; return; }

        records.forEach(rec => {
          let thumb = rec.thumbnail ? rec.thumbnail.replace('=s220', '=w600') : ''; 
          let large = rec.thumbnail ? rec.thumbnail.replace('=s220', '=w1600') : '';
          const missDisplay = rec.isFC ? `<span class="miss-val zero">FC-0</span>` : `FC -<span class="miss-val">${rec.missCount}</span>`;
          const badge = rec.isFC ? `<div class="fc-badge"><span class="material-symbols-outlined" style="font-size:1rem;">crown</span> FULL COMBO</div>` : '';
          const isSel = selectedIds.has(rec.id) ? 'selected' : '';

          // Conditional Actions
          let clickAction = "";
          let overlayActions = "";
          
          if (isSelectMode) {
              clickAction = `toggleSelection('${rec.id}')`;
          } else {
              clickAction = `openImageModal('${large}')`;
              overlayActions = `
                <div class="card-overlay-actions">
                    <div class="btn-overlay" onclick="event.stopPropagation(); individualEdit('${rec.id}')" title="編集"><span class="material-symbols-outlined">edit</span></div>
                    <div class="btn-overlay del" onclick="event.stopPropagation(); individualDelete('${rec.id}')" title="削除"><span class="material-symbols-outlined">delete</span></div>
                </div>
              `;
          }

          grid.innerHTML += `
            <div class="card ${rec.isFC?'is-fc':''} ${isSel} ${isSelectMode ? 'select-mode-active' : ''}" id="card-${rec.id}" onclick="${clickAction}">
              <div class="card-img-container">
                ${badge}
                ${overlayActions}
                <div class="img-loader-spinner"></div>
                ${thumb ? `<img src="${thumb}" class="card-img" loading="lazy" onload="this.style.opacity=1; this.previousElementSibling.style.display='none';">` : '<span style="color:#aaa;">NO IMAGE</span>'}
              </div>
              <div class="card-body">
                <div class="song-meta"><span class="tag lvl">Lv.${rec.level}</span><span class="tag diff-${rec.difficultyRaw}">${rec.difficulty}</span></div>
                <div class="song-title">${escapeHtml(rec.title)}</div>
                <div class="score-info"><span style="display:flex;align-items:center;gap:2px;"><span class="material-symbols-outlined" style="font-size:1rem;">bar_chart</span> Result</span>${missDisplay}</div>
              </div>
            </div>`;
        });
      }

      function openImageModal(src) { if(src) { document.getElementById('imageModal').style.display="flex"; document.getElementById('modalImg').src=src; } }
      function closeImageModal() { document.getElementById('imageModal').style.display="none"; }
      function parseFolderTitle(folderName) { const regex = /^(\d+)([AMEH])\s+(.+)$/; const match = folderName.match(regex); if (!match) return null; const diffMap = { 'A': 'APPEND', 'M': 'MASTER', 'E': 'EXPERT', 'H': 'HARD' }; return { level: parseInt(match[1], 10), rawDiff: match[2], difficulty: diffMap[match[2]] || match[2], title: match[3] }; }
      function parseScore(fileName) { const match = fileName.match(/^FC(?:-(\d+))?/); return match ? (match[1] === undefined ? 0 : parseInt(match[1], 10)) : null; }
      function onDataLoaded() { document.getElementById('loader').style.display = 'none'; updateView(); }
      function escapeHtml(t) { return t ? t.toString().replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m])) : ''; }
    </script>
  </body>
</html>
