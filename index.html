<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>プロセカ リザルト管理</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    
    <style>
      :root {
        --bg-color: #f4f7f6;
        --card-bg: #ffffff;
        --text-color: #333;
        --diff-append: #FF82C4;
        --diff-master: #AC3EE6;
        --diff-expert: #DC5268;
        --diff-hard:    #E9B153;
        --fc-color:     #FF82FF;
      }
      body { font-family: 'M PLUS Rounded 1c', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; }
      .container { max-width: 1200px; margin: 0 auto; }
      h2 { display: flex; align-items: center; gap: 10px; color: #444; }
      .material-symbols-outlined { font-size: 1.2rem; vertical-align: sub; }
      
      /* 認証ボタン周り */
      .auth-section { text-align: right; margin-bottom: 20px; display: flex; justify-content: flex-end; gap: 10px; }
      .btn-auth {
        background-color: #4285f4; color: white; border: none; padding: 10px 20px;
        border-radius: 4px; cursor: pointer; font-weight: bold; display: inline-flex; align-items: center; gap: 8px;
      }
      .btn-auth:hover { background-color: #357ae8; }
      .btn-signout { background-color: #dc3545; }
      .btn-signout:hover { background-color: #c82333; }
      .btn-upload { background-color: #28a745; }
      .btn-upload:hover { background-color: #218838; }
      #auth-status { margin-right: 10px; align-self: center; font-size: 0.9rem; color: #666; }

      /* Controls */
      .controls { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; }
      .control-group { display: flex; flex-direction: column; }
      .control-group label { font-size: 0.8rem; font-weight: bold; color: #777; margin-bottom: 6px; display: flex; align-items: center; gap: 4px; }
      select, input[type="number"], input[type="text"], input[type="file"] { padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: inherit; background-color: #fafafa; }
      
      .checkbox-wrapper { display: flex; align-items: center; gap: 8px; height: 42px; background-color: #fafafa; border: 1px solid #ddd; border-radius: 8px; padding: 0 10px; }
      input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; accent-color: var(--diff-master); }
      .checkbox-label { font-size: 0.9rem; cursor: pointer; user-select: none; }

      .status-bar { display: flex; justify-content: flex-end; margin-bottom: 15px; font-size: 0.9rem; color: #666; font-weight: bold; }
      .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 20px; }
      
      /* Card */
      .card { background: var(--card-bg); border-radius: 12px; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: transform 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; border: 2px solid transparent; position: relative; }
      .card:hover { transform: translateY(-3px); box-shadow: 0 8px 15px rgba(0,0,0,0.1); }
      .card.is-fc { border-color: var(--fc-color); }
      .card-img-container { width: 100%; height: 140px; background-color: #e0e2e5; overflow: hidden; position: relative; cursor: zoom-in; display: flex; justify-content: center; align-items: center; }
      .card-img { width: 100%; height: 100%; object-fit: contain; opacity: 0; transition: opacity 0.3s ease-in; position: relative; z-index: 2; }
      .img-loader-spinner { position: absolute; width: 24px; height: 24px; border: 3px solid #ddd; border-top: 3px solid #999; border-radius: 50%; animation: spin 1s linear infinite; z-index: 1; }
      
      /* Badges & Buttons on Card */
      .fc-badge { position: absolute; top: 8px; right: 8px; background: var(--fc-color); color: white; padding: 4px 10px; border-radius: 20px; font-weight: bold; font-size: 0.75rem; box-shadow: 0 2px 4px rgba(0,0,0,0.2); display: flex; align-items: center; gap: 4px; z-index: 3; }
      
      .card-actions { position: absolute; top: 8px; left: 8px; display: flex; gap: 5px; z-index: 10; }
      .action-btn { background: rgba(0,0,0,0.6); color: white; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: background 0.2s; }
      .btn-del:hover { background: #dc3545; }
      .btn-edit:hover { background: #007bff; }
      
      .card-body { padding: 12px; flex-grow: 1; display: flex; flex-direction: column; }
      .song-meta { display: flex; gap: 6px; margin-bottom: 8px; font-size: 0.75rem; }
      .tag { padding: 4px 8px; border-radius: 4px; font-weight: bold; color: white; letter-spacing: 0.5px; }
      .tag.lvl { background-color: #555; }
      .tag.diff-A { background-color: var(--diff-append); }
      .tag.diff-M { background-color: var(--diff-master); }
      .tag.diff-E { background-color: var(--diff-expert); }
      .tag.diff-H { background-color: var(--diff-hard); }
      .song-title { font-weight: bold; font-size: 0.95rem; margin-bottom: 12px; line-height: 1.4; }
      .score-info { font-size: 0.9rem; color: #666; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #f0f0f0; padding-top: 8px; margin-top: auto; }
      .miss-val { font-weight: bold; }
      .miss-val.zero { color: var(--fc-color); } 
      
      #loader { display: none; flex-direction: column; align-items: center; margin-top: 50px; color: #666; }
      .spinner { width: 40px; height: 40px; border: 4px solid #eee; border-top: 4px solid var(--diff-master); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 10px; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      
      /* Modals */
      .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.85); backdrop-filter: blur(5px); justify-content: center; align-items: center; }
      .modal-content-img { max-width: 90%; max-height: 90%; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); object-fit: contain; }
      
      /* Upload/Edit Modal Specific */
      .modal-form-content { background-color: #fff; padding: 25px; border-radius: 12px; width: 95%; max-width: 900px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); position: relative; max-height: 90vh; overflow-y: auto; display: flex; flex-direction: column; }
      .modal-body { display: flex; gap: 20px; flex-wrap: wrap; }
      .modal-left { flex: 1; min-width: 250px; border-right: 1px solid #eee; padding-right: 20px; display: flex; flex-direction: column; }
      .modal-right { flex: 2; min-width: 300px; }

      /* Queue List */
      .queue-list { list-style: none; padding: 0; margin: 0; max-height: 400px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; }
      .queue-item { padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; }
      .queue-item:hover { background-color: #f9f9f9; }
      .queue-item.active { background-color: #e6f7ff; border-left: 4px solid #007bff; }
      .queue-item.done { color: #28a745; }
      .queue-item.error { color: #dc3545; }
      .queue-status-icon { font-size: 1.2rem; }

      .modal-header { font-weight: bold; font-size: 1.2rem; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding-bottom: 10px; }
      .form-group { margin-bottom: 15px; }
      .form-group label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9rem; }
      .form-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; padding-top: 10px; border-top: 1px solid #eee; }
      .btn-cancel { background-color: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; }
      .btn-submit { background-color: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; }
      .btn-submit:disabled { background-color: #ccc; cursor: not-allowed; }
      .btn-update { background-color: #007bff; }
      .btn-update:hover { background-color: #0069d9; }
      
      /* Image Preview & Overlay */
      .preview-container { 
        text-align: center; margin-bottom: 15px; background: #f0f0f0; border-radius: 8px; overflow: hidden; display: none; min-height: 100px;
      }
      .preview-wrapper {
        position: relative;
        display: inline-block;
        max-width: 100%;
      }
      #preview-img { 
        display: block; max-width: 100%; max-height: 200px;
        height: auto; margin: 0 auto;
      }
      #debug-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
      }

      /* OCR Status */
      #ocr-status { 
        font-size: 0.85rem; color: var(--diff-master); font-weight: bold; margin-bottom: 10px; 
        min-height: 1.2em; white-space: pre-wrap; line-height: 1.5;
      }
      #ocr-status.error { color: #dc3545; }

      .close-btn { position: absolute; top: 20px; right: 30px; color: #fff; font-size: 40px; font-weight: bold; cursor: pointer; z-index: 1001; transition: color 0.2s; }
      .close-btn:hover { color: var(--fc-color); }
      
      @media (max-width: 700px) {
        .modal-body { flex-direction: column; }
        .modal-left { border-right: none; border-bottom: 1px solid #eee; padding-bottom: 20px; padding-right: 0; }
      }
    </style>
  </head>
  <body>

    <div id="imageModal" class="modal" onclick="if(event.target === this) closeImageModal()">
      <span class="close-btn" onclick="closeImageModal()">&times;</span>
      <img class="modal-content-img" id="modalImg">
    </div>

    <div id="uploadModal" class="modal" style="background-color: rgba(0,0,0,0.5);">
      <div class="modal-form-content">
        <div class="modal-header">
          <span id="modal-title"><span class="material-symbols-outlined">cloud_upload</span> リザルトアップロード</span>
          <span style="cursor:pointer;" onclick="closeUploadModal()">&times;</span>
        </div>
        
        <div class="modal-body">
          <div class="modal-left" id="modal-left-panel">
            <div id="upload-mode-ui">
                <div class="form-group">
                  <label>画像ファイル (複数可)</label>
                  <input type="file" id="up-file" multiple accept="image/*">
                </div>
                <label>アップロード待機リスト</label>
                <ul id="queue-list" class="queue-list">
                    <li style="padding:10px; color:#999; text-align:center;">ファイルを選択してください</li>
                </ul>
            </div>
            <div id="edit-mode-ui" style="display:none;">
                <p>既存のデータを修正します。<br>修正内容に応じてGoogle Drive上のファイル名や保存フォルダが自動的に更新されます。</p>
            </div>
          </div>

          <div class="modal-right">
            <div id="ocr-status"></div>

            <div class="preview-container" id="preview-box">
              <div class="preview-wrapper">
                <img id="preview-img" alt="プレビュー">
                <canvas id="debug-overlay"></canvas>
              </div>
            </div>

            <div class="form-group">
              <label>曲名 (タイトル)</label>
              <input type="text" id="up-title" placeholder="画像から自動入力されます" oninput="updateCurrentQueueItem()">
            </div>
            <div style="display:flex; gap:10px;">
              <div class="form-group" style="flex:1;">
                <label>レベル</label>
                <input type="number" id="up-level" placeholder="" oninput="updateCurrentQueueItem()">
              </div>
              <div class="form-group" style="flex:1;">
                <label>難易度</label>
                <select id="up-diff" onchange="updateCurrentQueueItem()">
                  <option value="A">Append</option>
                  <option value="M">Master</option>
                  <option value="E">Expert</option>
                  <option value="H">Hard</option>
                </select>
              </div>
            </div>
            <div class="form-group">
              <label>ミス数 (FCの場合は0)</label>
              <input type="number" id="up-miss" value="0" min="0" oninput="updateCurrentQueueItem()">
            </div>
          </div>
        </div>

        <div class="form-actions">
          <button class="btn-cancel" onclick="closeUploadModal()">閉じる</button>
          <button class="btn-submit" id="btn-submit-upload" onclick="handleBatchUpload()">一括アップロード</button>
          <button class="btn-submit btn-update" id="btn-submit-update" onclick="handleUpdate()" style="display:none;">更新する</button>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="auth-section">
        <span id="auth-status">未ログイン</span>
        
        <button id="upload_button" class="btn-auth btn-upload" onclick="openUploadModal()" style="display: none;">
          <span class="material-symbols-outlined">add_photo_alternate</span> アップロード
        </button>

        <button id="authorize_button" class="btn-auth" onclick="handleAuthClick()">
          <span class="material-symbols-outlined">login</span> Googleでログイン
        </button>
        <button id="signout_button" class="btn-auth btn-signout" onclick="handleSignoutClick()" style="display: none;">
          <span class="material-symbols-outlined">logout</span> ログアウト
        </button>
      </div>

      <h2><span class="material-symbols-outlined">library_music</span> リザルト管理 (My Drive)</h2>
      
      <div class="controls">
        <div class="control-group">
          <label><span class="material-symbols-outlined">sort</span> 並べ替え</label>
          <select id="sort-order" onchange="updateView()">
            <option value="title_asc">曲名 (昇順)</option>
            <option value="title_desc">曲名 (降順)</option>
            <option value="level_desc" selected>レベル (高い順)</option>
            <option value="level_asc">レベル (低い順)</option>
            <option value="miss_asc">失点数 (少ない順)</option>
            <option value="miss_desc">失点数 (多い順)</option>
          </select>
        </div>
        <div class="control-group">
          <label><span class="material-symbols-outlined">filter_alt</span> FC状況</label>
          <select id="filter-fc" onchange="updateView()">
            <option value="all">すべて</option>
            <option value="fc">FC済み (FC-0)</option>
            <option value="unfc">未FC (失点あり)</option>
          </select>
        </div>
        <div class="control-group">
          <label><span class="material-symbols-outlined">remove_circle</span> 失点数</label>
          <select id="filter-miss" onchange="updateView()">
            <option value="all">指定なし</option>
            <option value="range-1-5">1 ～ 5</option>
            <option value="range-6-10">6 ～ 10</option>
            <option value="range-11">11以上</option>
          </select>
        </div>
        <div class="control-group">
          <label><span class="material-symbols-outlined">speed</span> 難易度</label>
          <select id="filter-diff" onchange="updateView()">
            <option value="all">すべて</option>
            <option value="A">Append</option>
            <option value="M">Master</option>
            <option value="E">Expert</option>
            <option value="H">Hard</option>
          </select>
        </div>
        <div class="control-group">
          <label><span class="material-symbols-outlined">manage_search</span> 曲名検索</label>
          <input type="text" id="filter-title" placeholder="曲名を入力..." oninput="updateView()">
        </div>
        <div class="control-group">
          <label><span class="material-symbols-outlined">search</span> レベル検索</label>
          <input type="number" id="filter-level" placeholder="" oninput="updateView()">
        </div>
        <div class="control-group">
          <label><span class="material-symbols-outlined">star</span> 表示オプション</label>
          <div class="checkbox-wrapper">
            <input type="checkbox" id="filter-best" onchange="updateView()">
            <label for="filter-best" class="checkbox-label">自己ベストのみ</label>
          </div>
        </div>
      </div>

      <div class="status-bar">
        <span id="result-count">ログインしてください</span>
      </div>

      <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">データを読み込み中...</div>
      </div>
      
      <div id="grid" class="grid"></div>
    </div>

    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>

    <script>
      // ↓↓↓ GCPで取得した値を設定してください ↓↓↓
      const CLIENT_ID = '966636096862-8hrrm5heb4g5r469veoels7u6ifjguuk.apps.googleusercontent.com';
      const API_KEY = 'AIzaSyC-m1rkHuJTmNK2k-s89bJFshvXCS5MZZ0';
      // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
      
      const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
      const SCOPES = 'https://www.googleapis.com/auth/drive';

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;
      let allRecords = [];
      const diffRank = { 'A': 4, 'M': 3, 'E': 2, 'H': 1 };

      // --- 楽曲DBデータ ---
      let dbMusics = [];
      let dbDiffs = [];
      
      // Batch & Edit State
      let uploadQueue = []; // { file, title, level, diff, miss, status: 'pending'|'done'|'error', imgData, processed: bool }
      let currentQueueIndex = -1;
      let isEditMode = false;
      let editingRecord = null; // { id, parentId, title, ... }

      window.onload = async function() {
        try {
          const [musicsResp, diffsResp] = await Promise.all([
            fetch('https://sekai-world.github.io/sekai-master-db-diff/musics.json'),
            fetch('https://sekai-world.github.io/sekai-master-db-diff/musicDifficulties.json')
          ]);
          dbMusics = await musicsResp.json();
          dbDiffs = await diffsResp.json();
          console.log("DB Loaded:", dbMusics.length, dbDiffs.length);
        } catch (e) {
          console.error("DB Load Error:", e);
        }
      };

      // --- 認証関連 ---
      function gapiLoaded() { gapi.load('client', initializeGapiClient); }
      async function initializeGapiClient() {
        await gapi.client.init({ apiKey: API_KEY, discoveryDocs: [DISCOVERY_DOC], });
        gapiInited = true; maybeEnableButtons();
      }
      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({ client_id: CLIENT_ID, scope: SCOPES, callback: '', });
        gisInited = true; maybeEnableButtons();
      }
      function maybeEnableButtons() { if (gapiInited && gisInited) {} }
      function handleAuthClick() {
        tokenClient.callback = async (resp) => {
          if (resp.error !== undefined) throw (resp);
          setAuthUI(true); await fetchDataFromDrive();
        };
        if (gapi.client.getToken() === null) tokenClient.requestAccessToken({prompt: 'consent'});
        else tokenClient.requestAccessToken({prompt: ''});
      }
      function handleSignoutClick() {
        const token = gapi.client.getToken();
        if (token !== null) {
          google.accounts.oauth2.revoke(token.access_token);
          gapi.client.setToken('');
          setAuthUI(false);
          document.getElementById('result-count').innerText = 'ログアウトしました';
          document.getElementById('grid').innerHTML = '';
          allRecords = [];
        }
      }
      function setAuthUI(isLoggedIn) {
        document.getElementById('signout_button').style.display = isLoggedIn ? 'inline-flex' : 'none';
        document.getElementById('upload_button').style.display = isLoggedIn ? 'inline-flex' : 'none';
        document.getElementById('authorize_button').style.display = isLoggedIn ? 'none' : 'inline-flex';
        document.getElementById('auth-status').innerText = isLoggedIn ? 'ログイン済み' : '未ログイン';
      }

      // --- Drive データ取得ロジック ---
      async function fetchDataFromDrive() {
        const loader = document.getElementById('loader');
        loader.style.display = 'flex';
        document.getElementById('result-count').innerText = 'データ取得中...';
        document.getElementById('loader-text').innerText = 'フォルダ構造を解析中...';
        
        try {
          const ROOT_FOLDER_NAME = "プロセカリザルト";
          const rootFolder = await getFolderByName(ROOT_FOLDER_NAME);
          if (!rootFolder) { allRecords = []; onDataLoaded(); return; }

          const fcFolder = await getFolderByName("FC", rootFolder.id);
          if (!fcFolder) { allRecords = []; onDataLoaded(); return; }
          const sourceFolderId = fcFolder.id;

          document.getElementById('loader-text').innerText = '楽曲情報を取得中...';
          const folderQuery = `'${sourceFolderId}' in parents and mimeType = 'application/vnd.google-apps.folder' and trashed = false`;
          const songFolders = await fetchAllDriveItems(folderQuery, "id, name");
          
          const folderMap = new Map();
          songFolders.forEach(folder => {
            const metadata = parseFolderTitle(folder.name);
            if (metadata) folderMap.set(folder.id, metadata);
          });

          if (songFolders.length === 0) { allRecords = []; onDataLoaded(); return; }

          document.getElementById('loader-text').innerText = 'リザルト画像を検索中...';
          const fileQuery = `name contains 'FC' and mimeType != 'application/vnd.google-apps.folder' and trashed = false`;
          const candidateFiles = await fetchAllDriveItems(fileQuery, "id, name, parents, thumbnailLink");

          const records = [];
          candidateFiles.forEach(file => {
            if (!file.parents || file.parents.length === 0) return;
            const parentId = file.parents.find(p => folderMap.has(p));
            
            if (parentId) {
              const songInfo = folderMap.get(parentId);
              const missCount = parseScore(file.name);
              if (missCount !== null) {
                records.push({
                  id: file.id,
                  parentId: parentId, // For editing
                  title: songInfo.title,
                  level: songInfo.level,
                  difficulty: songInfo.difficulty,
                  difficultyRaw: songInfo.rawDiff,
                  missCount: missCount,
                  isFC: (missCount === 0),
                  thumbnail: file.thumbnailLink || null
                });
              }
            }
          });
          allRecords = records;
          onDataLoaded();
        } catch (e) {
          console.error(e);
          alert("データ取得中にエラーが発生しました: " + e.message);
          loader.style.display = 'none';
        }
      }

      async function fetchAllDriveItems(query, fields) {
        let items = []; let pageToken = null;
        do {
          const response = await gapi.client.drive.files.list({ q: query, fields: `nextPageToken, files(${fields})`, pageSize: 1000, pageToken: pageToken });
          const result = response.result;
          if (result.files && result.files.length > 0) items = items.concat(result.files);
          pageToken = result.nextPageToken;
        } while (pageToken);
        return items;
      }
      async function getFolderByName(name, parentId = null) {
        let query = `mimeType = 'application/vnd.google-apps.folder' and name = '${name}' and trashed = false`;
        if (parentId) query += ` and '${parentId}' in parents`;
        const response = await gapi.client.drive.files.list({ q: query, fields: 'files(id, name)', pageSize: 1 });
        const files = response.result.files;
        return (files && files.length > 0) ? files[0] : null;
      }
      async function findOrCreateFolder(name, parentId = null) {
        const existing = await getFolderByName(name, parentId);
        if (existing) return existing;
        const fileMetadata = { 'name': name, 'mimeType': 'application/vnd.google-apps.folder' };
        if (parentId) fileMetadata.parents = [parentId];
        const response = await gapi.client.drive.files.create({ resource: fileMetadata, fields: 'id, name' });
        return response.result;
      }
      async function deleteFile(fileId) { await gapi.client.drive.files.delete({ fileId: fileId }); }
      // ファイル移動用
      async function updateFileParent(fileId, oldParentId, newParentId) {
        if(oldParentId === newParentId) return;
        await gapi.client.drive.files.update({
          fileId: fileId,
          addParents: newParentId,
          removeParents: oldParentId,
          fields: 'id, parents'
        });
      }
      // ファイル名変更用
      async function renameFile(fileId, newName) {
        await gapi.client.drive.files.update({
          fileId: fileId,
          resource: { name: newName }
        });
      }

      // --- Modal Logic (Batch Upload & Edit) ---

      function openUploadModal() {
        isEditMode = false;
        setupModalUI();
        document.getElementById('uploadModal').style.display = 'flex';
      }

      function openEditModal(recordId) {
        const record = allRecords.find(r => r.id === recordId);
        if(!record) return;

        isEditMode = true;
        editingRecord = record;
        setupModalUI();
        
        // フォームに値をセット
        document.getElementById('up-title').value = record.title;
        document.getElementById('up-level').value = record.level;
        document.getElementById('up-diff').value = record.difficultyRaw;
        document.getElementById('up-miss').value = record.missCount;

        // プレビュー画像をサムネイルに（画質粗いが確認用）
        const previewImg = document.getElementById('preview-img');
        previewImg.src = record.thumbnail ? record.thumbnail.replace('=s220', '=w600') : '';
        document.getElementById('preview-box').style.display = "block";
        document.getElementById('uploadModal').style.display = 'flex';
      }

      function setupModalUI() {
        // Reset Inputs
        document.getElementById('up-title').value = "";
        document.getElementById('up-level').value = "";
        document.getElementById('up-miss').value = "0";
        document.getElementById('ocr-status').innerText = "";
        document.getElementById('ocr-status').className = "";
        
        const canvas = document.getElementById('debug-overlay');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // UI切替
        if (isEditMode) {
            document.getElementById('modal-title').innerHTML = '<span class="material-symbols-outlined">edit</span> リザルト編集';
            document.getElementById('upload-mode-ui').style.display = 'none';
            document.getElementById('edit-mode-ui').style.display = 'block';
            document.getElementById('btn-submit-upload').style.display = 'none';
            document.getElementById('btn-submit-update').style.display = 'inline-block';
        } else {
            document.getElementById('modal-title').innerHTML = '<span class="material-symbols-outlined">cloud_upload</span> リザルトアップロード';
            document.getElementById('upload-mode-ui').style.display = 'block';
            document.getElementById('edit-mode-ui').style.display = 'none';
            document.getElementById('btn-submit-upload').style.display = 'inline-block';
            document.getElementById('btn-submit-update').style.display = 'none';
            
            // Queue Reset
            uploadQueue = [];
            currentQueueIndex = -1;
            document.getElementById('up-file').value = "";
            document.getElementById('queue-list').innerHTML = '<li style="padding:10px; color:#999; text-align:center;">ファイルを選択してください</li>';
            document.getElementById('preview-box').style.display = "none";
            document.getElementById('preview-img').src = "";
            document.getElementById('btn-submit-upload').disabled = false;
        }
      }

      function closeUploadModal() {
        document.getElementById('uploadModal').style.display = 'none';
      }

      // --- Batch Processing Logic ---

      document.getElementById('up-file').addEventListener('change', async function(e) {
        if (!e.target.files || e.target.files.length === 0) return;
        
        const files = Array.from(e.target.files);
        const queueList = document.getElementById('queue-list');
        queueList.innerHTML = '';
        uploadQueue = [];

        // キュー初期化
        files.forEach((file, index) => {
            uploadQueue.push({
                index: index,
                file: file,
                title: '',
                level: '',
                diff: 'M',
                miss: 0,
                status: 'pending', // pending, processing, done, error
                imgData: null,
                processed: false
            });
            const li = document.createElement('li');
            li.className = 'queue-item';
            li.id = `queue-item-${index}`;
            li.innerHTML = `
                <span>${file.name}</span>
                <span class="queue-status-icon material-symbols-outlined">pending</span>
            `;
            li.onclick = () => selectQueueItem(index);
            queueList.appendChild(li);
        });

        // 順次解析開始
        processQueueAutomatically();
      });

      async function processQueueAutomatically() {
        const worker = await Tesseract.createWorker(['jpn', 'eng']);
        
        for (let i = 0; i < uploadQueue.length; i++) {
            const item = uploadQueue[i];
            updateQueueStatus(i, 'processing');
            if (i === 0) selectQueueItem(0); // 最初のアイテムを表示

            try {
                // 画像読み込み
                const img = new Image();
                const reader = new FileReader();
                const imgLoadPromise = new Promise(resolve => {
                    img.onload = () => resolve();
                    reader.onload = (e) => { img.src = e.target.result; item.imgData = e.target.result; };
                    reader.readAsDataURL(item.file);
                });
                await imgLoadPromise;

                // OCR実行 (既存ロジック再利用)
                const result = await runOcrOnImage(img, worker);
                
                // 結果保存
                item.title = result.title;
                item.level = result.level;
                item.diff = result.diff;
                item.miss = result.miss;
                item.processed = true;
                
                updateQueueStatus(i, 'done');
                
                // 現在表示中のアイテムならフォーム更新
                if (currentQueueIndex === i) {
                    fillFormWithItem(item);
                }

            } catch (err) {
                console.error(err);
                updateQueueStatus(i, 'error');
            }
        }
        await worker.terminate();
      }

      function updateQueueStatus(index, status) {
        const el = document.getElementById(`queue-item-${index}`);
        if (!el) return;
        const icon = el.querySelector('.queue-status-icon');
        
        if (status === 'processing') {
            icon.innerText = 'hourglass_top';
            icon.style.color = '#007bff';
        } else if (status === 'done') {
            icon.innerText = 'check_circle';
            el.classList.add('done');
        } else if (status === 'error') {
            icon.innerText = 'error';
            el.classList.add('error');
        }
      }

      function selectQueueItem(index) {
        if (index < 0 || index >= uploadQueue.length) return;
        
        // 旧アクティブ解除
        if (currentQueueIndex >= 0) {
            document.getElementById(`queue-item-${currentQueueIndex}`).classList.remove('active');
        }
        
        currentQueueIndex = index;
        document.getElementById(`queue-item-${index}`).classList.add('active');
        
        const item = uploadQueue[index];
        
        // 画像プレビュー
        if (item.imgData) {
            document.getElementById('preview-img').src = item.imgData;
            document.getElementById('preview-box').style.display = "block";
        }

        // フォーム反映
        fillFormWithItem(item);
        
        // ステータス表示
        const statusDiv = document.getElementById('ocr-status');
        if (item.processed) {
            statusDiv.innerText = `解析完了: ${item.title} (Lv.${item.level}) - MISS: ${item.miss}`;
            statusDiv.style.color = "#28a745";
        } else {
            statusDiv.innerText = "解析待ち...";
            statusDiv.style.color = "#666";
        }
    }

    function fillFormWithItem(item) {
        document.getElementById('up-title').value = item.title;
        document.getElementById('up-level').value = item.level;
        document.getElementById('up-diff').value = item.diff;
        document.getElementById('up-miss').value = item.miss;
    }

    // フォーム入力があったらキューデータを更新
    function updateCurrentQueueItem() {
        if (isEditMode) return; // 編集モードは何もしない
        if (currentQueueIndex < 0) return;

        const item = uploadQueue[currentQueueIndex];
        item.title = document.getElementById('up-title').value.trim();
        item.level = document.getElementById('up-level').value.trim();
        item.diff = document.getElementById('up-diff').value;
        item.miss = document.getElementById('up-miss').value;
    }

      // --- OCR Core Logic (Extracted) ---
      async function runOcrOnImage(imgElement, worker) {
        const canvas = document.createElement('canvas'); // Temporary for cropping
        
        // 1. Difficulty
        const rDiff = {x:0.20, y:0.07, w:0.10, h:0.04};
        const diffBlob = await cropImage(imgElement, rDiff.x, rDiff.y, rDiff.w, rDiff.h, 'threshold-diff');
        const diffRet = await worker.recognize(diffBlob, { lang: 'eng' });
        const diffText = diffRet.data.text.toUpperCase();
        
        let dCode = "M"; // Default
        let dKey = "master";
        if (diffText.match(/A?P{2}E?N?D?/)) { dCode = "A"; dKey = "append"; }
        else if (diffText.includes("MASTER")) { dCode = "M"; dKey = "master"; }
        else if (diffText.includes("EXPERT")) { dCode = "E"; dKey = "expert"; }
        else if (diffText.includes("HARD")) { dCode = "H"; dKey = "hard"; }

        // 2. Title
        const rTitle = {x:0.19, y:0.01, w:0.32, h:0.05};
        const titleBlob = await cropImage(imgElement, rTitle.x, rTitle.y, rTitle.w, rTitle.h, 'filter-standard');
        const titleRet = await worker.recognize(titleBlob, { lang: 'jpn' });
        const titleText = titleRet.data.text;
        
        const matchedMusic = findBestMatchMusic(titleText);
        const finalTitle = matchedMusic ? matchedMusic.title : titleText.replace(/\r?\n/g, '').trim();
        const musicId = matchedMusic ? matchedMusic.id : null;

        // 3. Level
        let finalLevel = "";
        if (musicId && dKey) {
             const diffEntry = dbDiffs.find(d => d.musicId === musicId && d.musicDifficulty === dKey);
             if (diffEntry) finalLevel = diffEntry.playLevel;
        }

        // 4. Miss
        const rMiss = {x:0.10, y:0.55, w:0.20, h:0.28};
        const missBlob = await cropImage(imgElement, rMiss.x, rMiss.y, rMiss.w, rMiss.h, 'filter-standard');
        const missRet = await worker.recognize(missBlob, { lang: 'jpn' });
        const missText = missRet.data.text;
        
        const lines = missText.split('\n');
        let cG = 0, cB = 0, cM = 0;
        const parseLine = (line, regex) => {
            if (regex.test(line)) {
                const nums = line.match(/\d+/g);
                if (nums && nums.length > 0) return parseInt(nums[nums.length - 1], 10);
            } return 0;
        };
        const regGood = /G[O0QD]{2}D/i; const regBad = /BAD/i; const regMiss = /MISS/i;
        lines.forEach(line => {
            if (regGood.test(line)) cG = parseLine(line, regGood);
            if (regBad.test(line))  cB  = parseLine(line, regBad);
            if (regMiss.test(line)) cM = parseLine(line, regMiss);
        });

        return {
            title: finalTitle,
            level: finalLevel,
            diff: dCode,
            miss: cG + cB + cM
        };
      }

      // --- Helper Functions (Crop, OCR utils) ---
      async function cropImage(imageElement, xRatio, yRatio, wRatio, hRatio, type = 'filter-standard') {
        const canvas = document.createElement('canvas');
        const w = imageElement.naturalWidth;
        const h = imageElement.naturalHeight;
        const ctx = canvas.getContext('2d');
        if (type === 'threshold-diff') {
            const scale = 1.5;
            canvas.width = w * wRatio * scale; canvas.height = h * hRatio * scale;
            ctx.drawImage(imageElement, w * xRatio, h * yRatio, w * wRatio, h * hRatio, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                if (gray > 180) { data[i] = data[i+1] = data[i+2] = 0; } else { data[i] = data[i+1] = data[i+2] = 255; }
            }
            ctx.putImageData(imageData, 0, 0);
        } else {
            canvas.width = w * wRatio; canvas.height = h * hRatio;
            ctx.filter = 'grayscale(100%) contrast(150%)';
            ctx.drawImage(imageElement, w * xRatio, h * yRatio, w * wRatio, h * hRatio, 0, 0, canvas.width, canvas.height);
        }
        return new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
      }
      function normalizeString(str) {
        if (!str) return "";
        return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).toLowerCase().replace(/[\s\-_]/g, '');
      }
      function levenshteinDistance(s1, s2) {
        if (s1.length > s2.length) [s1, s2] = [s2, s1];
        let distances = Array.from({ length: s1.length + 1 }, (_, i) => i);
        for (let i2 = 0; i2 < s2.length; i2++) {
            let newDistances = [i2 + 1];
            for (let i1 = 0; i1 < s1.length; i1++) {
                if (s1[i1] === s2[i2]) newDistances.push(distances[i1]);
                else newDistances.push(1 + Math.min(distances[i1], distances[i1 + 1], newDistances[newDistances.length - 1]));
            }
            distances = newDistances;
        }
        return distances[distances.length - 1];
      }
      function findBestMatchMusic(ocrText) {
        if (!dbMusics || dbMusics.length === 0) return null;
        const target = normalizeString(ocrText); if (target.length === 0) return null;
        let best = null; let minScore = Infinity; 
        for (const m of dbMusics) {
            const dbT = normalizeString(m.title); const dist = levenshteinDistance(target, dbT);
            const score = dist / Math.max(target.length, dbT.length);
            if (score < minScore) { minScore = score; best = m; }
        }
        return best; 
      }

      // --- Batch Upload Action ---

      async function handleBatchUpload() {
        if (uploadQueue.length === 0) { alert("アップロードするファイルがありません。"); return; }
        
        const btn = document.getElementById('btn-submit-upload');
        btn.disabled = true;
        
        try {
            const accessToken = gapi.client.getToken().access_token;
            const rootFolder = await findOrCreateFolder("プロセカリザルト");
            const fcFolder = await findOrCreateFolder("FC", rootFolder.id);

            let successCount = 0;
            
            for (let i = 0; i < uploadQueue.length; i++) {
                const item = uploadQueue[i];
                if (!item.title || !item.level) continue;

                // UI update
                btn.innerText = `送信中 (${i+1}/${uploadQueue.length})...`;

                const songFolderName = `${item.level}${item.diff} ${item.title}`;
                const songFolder = await findOrCreateFolder(songFolderName, fcFolder.id);
                const fileName = (parseInt(item.miss) === 0) ? "FC" : `FC-${item.miss}`;
                
                const metadata = { 'name': fileName, 'parents': [songFolder.id] };
                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', item.file);

                const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                    method: 'POST',
                    headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),
                    body: form
                });
                if (response.ok) successCount++;
            }

            alert(`${successCount} 件のアップロードが完了しました！`);
            closeUploadModal();
            await fetchDataFromDrive();

        } catch (e) {
            console.error(e);
            alert("エラーが発生しました: " + e.message);
        } finally {
            btn.disabled = false;
            btn.innerText = "一括アップロード";
        }
      }

      // --- Edit/Update Action ---

      async function handleUpdate() {
        if (!editingRecord) return;
        
        const newTitle = document.getElementById('up-title').value.trim();
        const newLevel = document.getElementById('up-level').value.trim();
        const newDiff = document.getElementById('up-diff').value;
        const newMiss = document.getElementById('up-miss').value;
        
        if (!newTitle || !newLevel) { alert("項目を入力してください。"); return; }

        const btn = document.getElementById('btn-submit-update');
        btn.disabled = true;
        btn.innerText = "更新中...";

        try {
            // 1. フォルダパスの確認・作成
            const rootFolder = await findOrCreateFolder("プロセカリザルト");
            const fcFolder = await findOrCreateFolder("FC", rootFolder.id);
            const songFolderName = `${newLevel}${newDiff} ${newTitle}`;
            
            // 既存の親フォルダIDと比較
            const existingParent = await gapi.client.drive.files.get({fileId: editingRecord.parentId});
            let targetFolderId = editingRecord.parentId;
            
            // フォルダ名が変わる（構成要素が変わった）場合は移動が必要
            if (existingParent.result.name !== songFolderName) {
                const newFolder = await findOrCreateFolder(songFolderName, fcFolder.id);
                targetFolderId = newFolder.id;
                await updateFileParent(editingRecord.id, editingRecord.parentId, targetFolderId);
            }

            // 2. ファイル名の更新
            const newFileName = (parseInt(newMiss) === 0) ? "FC" : `FC-${newMiss}`;
            // 現在のファイル名を取得して比較（API節約のため省略可だが念のため）
            if (editingRecord.missCount != newMiss) { // 簡易比較
                 await renameFile(editingRecord.id, newFileName);
            } else {
                 // FC状況が変わっていなくてもリネームを強制して整合性を保つ
                 await renameFile(editingRecord.id, newFileName);
            }

            alert("更新しました！");
            closeUploadModal();
            await fetchDataFromDrive();

        } catch (e) {
            console.error(e);
            alert("更新エラー: " + e.message);
        } finally {
            btn.disabled = false;
            btn.innerText = "更新する";
        }
      }

      // --- Deletion Logic ---

      async function confirmDelete(fileId, title) {
        event.stopPropagation();
        if (confirm(`「${title}」のリザルト画像を削除しますか？\n（Google Driveのゴミ箱に移動します）`)) {
          const loader = document.getElementById('loader');
          loader.style.display = 'flex';
          document.getElementById('loader-text').innerText = '削除中...';
          document.getElementById('grid').innerHTML = ''; 
          try {
            await deleteFile(fileId);
            alert("削除しました。");
            await fetchDataFromDrive();
          } catch (e) {
            console.error(e);
            alert("削除に失敗しました: " + e.message);
            loader.style.display = 'none';
          }
        }
      }

      // --- Parsing Helpers (Same as before) ---
      function parseFolderTitle(folderName) {
        const regex = /^(\d+)([AMEH])\s+(.+)$/;
        const match = folderName.match(regex);
        if (!match) return null;
        const diffMap = { 'A': 'Append', 'M': 'Master', 'E': 'Expert', 'H': 'Hard' };
        return {
          level: parseInt(match[1], 10),
          rawDiff: match[2],
          difficulty: diffMap[match[2]] || match[2],
          title: match[3]
        };
      }
      function parseScore(fileName) {
        const regex = /^FC(?:-(\d+))?/;
        const match = fileName.match(regex);
        if (match) return match[1] === undefined ? 0 : parseInt(match[1], 10);
        return null;
      }

      // --- UI Logic (Rendering) ---
      function getDiffScore(rawDiff) { return diffRank[rawDiff] || 0; }
      function onDataLoaded() {
        document.getElementById('loader').style.display = 'none';
        updateView();
      }
      function updateView() {
        if (!allRecords) return;
        const fcFilter = document.getElementById('filter-fc').value;
        const missFilter = document.getElementById('filter-miss').value;
        const diffFilter = document.getElementById('filter-diff').value;
        const levelFilter = document.getElementById('filter-level').value;
        const bestOnly = document.getElementById('filter-best').checked;
        const titleFilter = document.getElementById('filter-title').value.trim().toLowerCase();

        let sourceRecords = allRecords;

        if (bestOnly) {
          const bestMap = new Map();
          sourceRecords.forEach(rec => {
            const key = rec.title + '_' + rec.difficultyRaw;
            if (!bestMap.has(key)) bestMap.set(key, rec);
            else {
              const currentBest = bestMap.get(key);
              if (rec.missCount < currentBest.missCount) bestMap.set(key, rec);
            }
          });
          sourceRecords = Array.from(bestMap.values());
        }

        let filtered = sourceRecords.filter(record => {
          if (fcFilter === 'fc' && !record.isFC) return false;
          if (fcFilter === 'unfc' && record.isFC) return false;
          if (missFilter !== 'all') {
             if (record.isFC) return false;
             if (missFilter === 'range-1-5' && (record.missCount < 1 || record.missCount > 5)) return false;
             if (missFilter === 'range-6-10' && (record.missCount < 6 || record.missCount > 10)) return false;
             if (missFilter === 'range-11' && record.missCount < 11) return false;
          }
          if (diffFilter !== 'all' && record.difficultyRaw !== diffFilter) return false;
          if (levelFilter && record.level != levelFilter) return false;
          if (titleFilter && !record.title.toLowerCase().includes(titleFilter)) return false;
          return true;
        });

        const sortOrder = document.getElementById('sort-order').value;
        filtered.sort((a, b) => {
          const titleAsc = a.title.localeCompare(b.title, 'ja');
          const titleDesc = b.title.localeCompare(a.title, 'ja');
          const levelDesc = b.level - a.level;
          const levelAsc = a.level - b.level;
          const diffDesc = getDiffScore(b.difficultyRaw) - getDiffScore(a.difficultyRaw); 
          const missAsc = a.missCount - b.missCount;
          const missDesc = b.missCount - a.missCount;

          switch (sortOrder) {
            case 'title_asc': return titleAsc || diffDesc || missAsc;
            case 'title_desc': return titleDesc || diffDesc || missAsc;
            case 'level_desc': return levelDesc || titleAsc || diffDesc || missAsc;
            case 'level_asc': return levelAsc || titleAsc || diffDesc || missAsc;
            case 'miss_asc': return missAsc || levelDesc || diffDesc || titleAsc;
            case 'miss_desc': return missDesc || levelDesc || diffDesc || titleAsc;
            default: return 0;
          }
        });
        renderGrid(filtered);
      }

      function renderGrid(records) {
        const grid = document.getElementById('grid');
        const countLabel = document.getElementById('result-count');
        countLabel.textContent = `表示: ${records.length} 件`;
        grid.innerHTML = '';

        if (records.length === 0) {
          grid.innerHTML = '<div style="grid-column: 1/-1; text-align:center; padding:20px; color:#666;">該当するデータがありません</div>';
          return;
        }

        records.forEach(rec => {
          let thumbUrl = rec.thumbnail ? rec.thumbnail.replace('=s220', '=w600') : ''; 
          let largeUrl = rec.thumbnail ? rec.thumbnail.replace('=s220', '=w1600') : '';
          const fcClass = rec.isFC ? 'is-fc' : '';
          const missDisplay = rec.isFC ? `<span class="miss-val zero">FC-0</span>` : `FC -<span class="miss-val">${rec.missCount}</span>`;
          const badge = rec.isFC ? `<div class="fc-badge"><span class="material-symbols-outlined" style="font-size:1rem;">crown</span> FULL COMBO</div>` : '';

          const html = `
            <div class="card ${fcClass}">
              <div class="card-img-container" onclick="openImageModal('${largeUrl}')">
                <div class="card-actions">
                  <button class="action-btn btn-del" onclick="confirmDelete('${rec.id}', '${escapeHtml(rec.title)}')" title="削除">
                    <span class="material-symbols-outlined">delete</span>
                  </button>
                  <button class="action-btn btn-edit" onclick="event.stopPropagation(); openEditModal('${rec.id}')" title="編集">
                    <span class="material-symbols-outlined">edit</span>
                  </button>
                </div>
                ${badge}
                <div class="img-loader-spinner"></div>
                ${thumbUrl ? `<img src="${thumbUrl}" class="card-img" loading="lazy" onload="this.style.opacity=1; this.previousElementSibling.style.display='none';">` : '<span style="color:#aaa;">NO IMAGE</span>'}
              </div>
              <div class="card-body">
                <div class="song-meta">
                  <span class="tag lvl">Lv.${rec.level}</span>
                  <span class="tag diff-${rec.difficultyRaw}">${rec.difficulty}</span>
                </div>
                <div class="song-title">${escapeHtml(rec.title)}</div>
                <div class="score-info">
                  <span style="display:flex; align-items:center; gap:2px;">
                    <span class="material-symbols-outlined" style="font-size:1rem;">bar_chart</span> Result
                  </span>
                  ${missDisplay}
                </div>
              </div>
            </div>
          `;
          grid.innerHTML += html;
        });
      }

      function openImageModal(src) {
        if(!src) return;
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImg');
        modal.style.display = "flex";
        modalImg.src = src;
      }
      function closeImageModal() { document.getElementById('imageModal').style.display = "none"; }
      function escapeHtml(text) {
        if (!text) return '';
        return text.toString().replace(/[&<>"']/g, function(m) { return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m]; });
      }
    </script>
  </body>
</html>
